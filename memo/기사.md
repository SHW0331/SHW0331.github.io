/*
 * 정보보안기사
 * PART 01. 정보보호 개요
 * PART 02. 암호학
 * PART 03. 정보보호 개요
 * PART 04. 정보보호 개요
 */

PART 1. 정보보호 개요
- 1.0 정보보호관리의 개념
    # 정보보호 정의 (기물관!!)
    - 정보의 수집, 가공, 저장, 검색, 송신, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단, 또는 그러한 수단으로 이루어지는 행위
    - 기밀성, 무결성, 가용성, 인증성, 부인방지를 보장하기 위해 기술적, 물리적, 관리적 보호대책을 강구하는 것

    # 3대 목표 + 속성 -- (기가무인!!, 접부!!)
    - 기밀성(Confidentiality) : 인가된 사람, 프로세스, 시스템만이 알 필용성에 근거하여 시스템에 접근 할 수 있어야 함
    - 가용성(Availability) : 시스템이 지체 없이 동작하고, 자원이 필요할 때 권한이 있는 사용자가 이용
    - 무결성(Integrity) : 정보의 내용이 무단으로 생성 또는 변경되거나 삭제되지 않도록 보호
    - 인증성(Authentication) : 통신 대상에 대한 인증, 데이터의 출처에 대한 인증
    # 3대 목표 + 속성 (추가적으로)
    - 부인방지(Non-repudiation) : 전송이나 수신한 사실을 부인하지 못하도록 하는 것
    - 접근제어(Access Control)

    # -----------------------------------------------------------------------------------------------------

    # 보안 공격 (Passive)
    - Snooping : Passive(소극적 공격) : Confidentiality(기밀성)
    - Traffic Analysis : Passive(소극적 공격) : Confidentiality(기밀성)

    # 보안 공격 (Active) -- (가변부재!!)
    - Modification(변경) : Active(적극적 공격) : Integrity(무결성)
    - Masquerading(가장) : Active(적극적 공격) : Integrity(무결성)
    - Replaying(재연, 재전송) : Active(적극적 공격) : Integrity(무결성)
    - Repudiation(부인) : Active(적극적 공격) : Integrity(무결성)

    # 보안 공격
    - Denial of Service(DoS) : Active(적극적 공격) : Availability(가용성)

    # -----------------------------------------------------------------------------------------------------

    # 시점별 통제
    - 예방통제 : 사전에 위협과 취약점에 대처하는 통제
    - 탐지통제 : 위협을 탐지하는 통제, 빠르게 탐지할수록 대처하기 용이
    - 교정통제 : 이미 탐지된 위협이나 취약점에 대처/감소시키는 통제

    # 시점별 통제 (순서)
    - 예방 -> 탐지 -> 교정 순으로 적용

    # -----------------------------------------------------------------------------------------------------
    
    # 주요 보안 용어
    - 자산(Asset) : 조직이 보호해야 할 대상
    - 취약점(Vulnerability) : 위협의 이용대상으로 관리적, 물리적, 기술적 약점을 의미 (기물관)
    - 위협(Threat) : 손실이나 손상의 원인이 될 가능성을 제공하는 환경의 집합
    - 위험(Risk) : 공격자(위협 주체)가 취약점을 이용하여 위협이라는 행동을 통해 자산에 악영향을 미치는 결과를 가지고 올 가능성

    # -----------------------------------------------------------------------------------------------------

PART 2. 암호학
- 2.0 암호학 개요
    # 암호화와 복호화
    - 평문(Message, Plain-text) : M, P
    - 암호문(Cypher-text) : C
    - 암호화(Encryption) 알고리즘 : E
    - 복호화(Decryption) 알고리즘 : D
    - 키(key) : K

    # 암호화와 복호화 (기호적 표현) 
    - 암호화 : C = E(K,P) / C = E_k(P)
    - 복호화 : P = D(K,C) / P = D_K(C)

    # -----------------------------------------------------------------------------------------------------
    
    # 치환 암호와 전치 암호
    - 치환 암호(대치 암호, Substitution Cipher) : 평문의 문자를 다른 문자로 교환(대체)하는 암호기법
    - 전치 암호(Transposition) : 문자 집합 내부에서 자리를 바꾸는(재배열) 암호기법. 평문의 문자 집합과 암호문의 문자 집합이 일대일 대응 규칙을 갖는다.

    # -----------------------------------------------------------------------------------------------------

    # 블록 암호와 스트림 암호
    - 블록 암호(Block Cipher) : 평문을 특정 비트의 블록으로 잘라낸 후 암호화 알고리즘을 적용하여 암호화
    - 스트림 암호(Stream Cipher)
        - 데이터 흐름(스트림)을 순차적으로 처리해가는 암호 알고리즘.
        - 데이터 흐름을 순차적으로 처리하기 때문에 내부 상태를 가지고 있다.
        - 긴 주기와 높은 선형 복잡도가 요구된다.
        - 속도는 블록 암호화 방식보다 빠르지만 암호화 강도가 약하므로 이동 통신 등의 무선 데이터 보호에 적합

    # -----------------------------------------------------------------------------------------------------
    
    # 위치에 따른 암호화 구분
    - 링크 암호화(Link Encryption) : 통신 링크 양쪽 끝단에 암호화 장치를 놓는 것. 대형 네트워크에서 사용하면 필요한 암호화 장치 수가 많아지고, 중간 노드에서 데이터가 평문으로 노출된다는 단점이 있다.
    - 종단간 암호화(End-to-End Encryption) : 두 종단 시스템에서 수행됨. 트래픽 분석에는 취약하지만 링크 암호화 방식보다 높은 보안 서비스를 제공한다.

    # -----------------------------------------------------------------------------------------------------

    # 주요 암호 기술
    - 대칭키 암호와 비대칭키 암호
        - 대칭키 암호(Symmetric Cryptography) : '암호화키 = 복호화키'인 알고리즘 방식
        - 비대칭키 암호(Asymmetric Cryptography) : '암호화키 != 복호화키'인 암호 알고리즘 방식
    - 하이브리드 암호 시스템 : 대칭키 암호 + 비대칭키 암호
    - 일방향 해시함수(one-way hash function)
    - 메시지 인증 코드(MAC, Message Authentication Code) : 무결성과 인증을 제공
    - 전자서명 : 무결성을 확인하고, 인증과 부인방지를 제공
    - 의사난수 생성기(PRNG, Pseudo Random Number Generator) : 키 생성의 역할

    # -----------------------------------------------------------------------------------------------------

    # 암호 분석(암호 해독) 분류
    - 암호문 단독 공격(COA, Cipher-text Only Attack) : 암호문 C만을 갖고 평문 P나 키 K를 찾아내는 방법.
    - 기지 평문 공격(KPA, Known Plain-text Attack)
        - 일정량의 평문 P에 대응하는 암호문 C를 알고 있는 상태에서 해독하는 방법.
        - 암호문 C와 평문 P의 관계로부터 키 K나 평문 P를 추정하여 해독하는 방법.
    - 선택 평문 공격(CPA, Chosen Plain-text Attack) : 송신자(암호기)에 접근이 가능하여 평문 P를 선택하면 그 평문 P에 대한 암호문 C를 얻어 해독하는 방법.
    - 선택 암호문 공격(CCA, Chosen Cypher-text Attack) :수신자(복호기)에 접근이 가능하여 엄호문 C를 선택하면 그 암호문 C에 대한 평문 P를 얻어내 암호를 해독하는 방법
    - COA -> KPA -> CPA, CAA 순서로 공격자의 능력이 향상. 따라서 높은 단계의 공격자에게 안전한 암호 방식을 설계하는 것이 일반적인 암호 설계 방향이다.

    # -----------------------------------------------------------------------------------------------------

    # 암호 알고리즘의 안정성 평가
    - CC(Common Criteria) : 정보보호시스템에 대한 공통 평가 기준
    - CMVP(Cryptographic Module Validation Program) : 미국 NIST와 캐나다 CSE가 개발한 암호 모듈의 안전성 검증을 위한 프로그램. 암호기술의 구현 적합성 평가, 암호키 운용 및 관리, 물리적 보안으로 크게 나뉘어 평가를 수행

    # -----------------------------------------------------------------------------------------------------

    # 디지털 저작권 관리
    - 스태가노그래피(Steganography) : 메시지 내용이 아닌 메시지 자체를 은폐하는 기법
    - 워터마크
        - 원본의 내용을 왜곡하지 않는 선에서 저작권 정보를 디지털 콘첸츠에 삽입하는 기법
        - 강한(강성) 워터마킹 : 공격을 받아도 쉽게 파괴되거나 손상을 입지 않음
        - 약한(연성) 워터마킹 : 공격을 받으면 쉽게 파괴되거나 손상을 입음
    - 핑거프린팅(Fingerprinting)
        - 디지털 콘텐츠를 구매할 때 구매자의 정보를 삽입하는 기법
        - 불법 배포 발견 시 최초의 배포자를 추적하기 위한 기술
    - 디지털 저작권 관리(DRM, Digital Rights Management)
        - 메타데이터(Metadata) : 콘텐츠 생명주기 범위 내에서 관리되어야 할 각종 데이터의 구조 및 정보
        - 패키저(Packager) : 보호 대상인 콘텐츠를 메타데이터와 함께 Secure Container 포맷으로 패키징 하는 모듈
        - 시큐어 컨테이너(Secure Container) : DRM의 보호 범위 내에서 유통되는 콘텐츠의 배포 단위
        - 식별자(Identifier) : 콘텐츠를 식별하기 위한 식별자
        - DRM 제어기(DRM Controller) : 콘텐츠를 이용하는 사용자의 PC 또는 디바이스 플랫폼에서 컨텐츠가 라이선스에 명시된 범위 내에서 지속적으로 보호될 수 있도록 프로세스를 제어
        - DRM이 적용 된 기술
            - PKI 기반의 불법복제 방지 기술
                - 콘텐츠 소비자의 암호화 키를 이용하여 패키징 함으로써 이를 다른 사람들이 이용할 수 없도록 하는 방식
                - 콘텐츠 배포 서버의 부담이 크다는 단점이 있어 디지털 유통에 적합하지 않음
            - DOI(Digital Object Identifier)
                - 저작권 관리 정보를 바탕으로 저작권 인증을 부여하는 기술
                - 불법복제 및 불법사용 방지 기능이 제공되지 않아 적극적인 보호가 불가능
    
    # -----------------------------------------------------------------------------------------------------

    # 대칭키 암호 정의
    - 대칭키 암호 = 관용 암호 = 공통키 암호 = 비밀키 암호

    # -----------------------------------------------------------------------------------------------------

    # 블록 암호
    - 확산과 혼돈
        - Shannon이 정의한 개념
        - 확산(diffusion) : 암호문 C와 평문 P 사이의 관계를 숨기는 것 (C - P)
        - 혼돈(confusion) : 암호문 C와 키 K의 관계를 숨기는 것 (C - K)
    - P-box (전치 장치, Permutation box), 확산 제공
        - 단순 P-box : n 비트를 입력 받아 n 비트를 출력, 유일하게 역함수가 존재
        - 축소 P-box : n 비트를 입력 받아 m 비트를 출력 (n > m)
        - 확장 P-box : n 비트를 입력 받아 m 비트를 출력 (n < m)
    - S-box (치환 장치, Substitution box), 혼돈 제공
        - 역함수가 존재하는 S-box : 입력 비트 = 출력 비트
        - 역함수가 존재하지 않는 S-box : 입력 비트 != 출력 비트
    - Fesital 암호 구조
        - 암호화 과정 = 복호화 과정
        - 암호 강도를 결정짓는 요소
            - 평문 M의 길이
            - 키 K의 길이
            - 라운드 수
    - SPN 암호 구조
        - Substitution-Permutation Network
        - S-box, P-box 반복적으로 사용하는 구조
    
    # -----------------------------------------------------------------------------------------------------

    # 블록암호에 대한 공격
    - 차분 분석 : 평문의 한 비트를 변경하면 암호문은 전혀 다른 비트 패턴으로 변화하므로, 이 변화 형태를 분석하는 공격
    - 선형 분석 : 평문 비트와 암호문 비트를 일부 XOR하는 과정으로 근사적 선형 관계를 찾는 방법
    - 전수 공격
        - 가능한 모든 경우에 대해 공격하는 방법
        - 경우의 수가 적은 경우 효율적인 방법
    - 통게적 분석 : 통게적인 자료를 통해 해독하는 방법
    - 수학적 분석 : 통게적 분석을 포함하여 수학적 이론을 이용하여 해독하는 방법

    # -----------------------------------------------------------------------------------------------------

    # 스트림 암호
    - 동기식 스트림 암호
        - 키 스트림은 평문 or 암호문 스트림과 독립적이다.
        - 암호화, 복호화에서 상호 동기화가 필수적이며, 전송도중 변조되어도 후속 암호문에 오류의 영향이 없다.
        - One-Time Pad
            - 암호화를 수행할 때마다 랜덤하게 선택된 키 스트림을 사용
            - 이론적으로 해독이 불가능하다는 것이 Shannon에 의해 증명됨.
        - 귀환 시프트 레지스터 (Feedback Shift Register, FSR)
        - 선형 귀환 시프트 레지스터 (Linear Feedback Shift Register, LFSR) : 많은 스트림 암호가 이를 이용하며, 선형성 때문에 공격에 취약
        - 비선형 귀환 시프트 레지스터 (Non-Linear Feedback Shift Register, NLFSR)

    - 비동기식(자기 동기식) 스트림 암호
        - 키 스트림은 평문 or 암호문 스트림에 종속적이다.
        - 암호문이 전송도중 변경되어도 자기 동기화가 가능
        - 변조된 암호문이 후속 암호문 복호화에 사용되지 않아 후속 암호문에 오류의 영향이 없다.

    # -----------------------------------------------------------------------------------------------------

    # DES(Data Encryption Standard)
    - 평문 = 64bits
    - 키 = 56bit (오류검출비트 8bit 제외)
    - 라운드 횟수 = 16회
    - 두 개의 P-box와 16개의 Feistel 라운드 함수로 구성
    - 키 생성기에 의해 48bit의 라운드 키가 생성

    - P-Box
    - Round 1    <--- K_1 (48bits)
    - ....                         <--- Round-key 생성기 <--- 56bits Cipher-key
    - Round 16   <--- K_16 (48bits)
    - P-Box

    - DES 함수
        - 확장 P-box -> 라운드 키와 XOR 연산 -> 8개의 S-box -> 단순 P-box로 구성되어 있다.
        - S-Box는 비선형 함수이며, 혼돈을 제공
    - DES의 취약점 : 56bits의 작은 키

    # 3DES(3중 DES)
    - H/W에서 효율적이지만 S/W에서 비효율적
    - 처리 속도가 느리다.
    - 두개의 키를 갖는 3DES : 암호화 - 복호화 - 암호화 과정을 거쳐서 암호문이 만들어진다.
    - 세 개의 키를 가는 3DES : 두 개의 키를 갖는 3DES에 대한 기지평문공격(KPA) 가능성 때문에 사용
    - 3DES에서 모든 키를 동일하게 하면, 보통의 DES가 된다.

    # -----------------------------------------------------------------------------------------------------

    # AES(Advanced Encryption Standard)
    - NIST(미국 국립기술표준원)에서 공모한 암호 알고리즘으로, 라안달(Rijndael)이 채택되었다.
    - non-Feistel 알고리즘, SPN 구조.
    - 키의 길이에 따라 라운드가 바뀐다.
    - (key, Round)
        - (128bits, 10)
        - (192bits, 12)
        - (256bits, 14)
    - AES 단계
        - 평문을 byte 단위로 나눔
        - SubBytes (바이트 치환) : 바이트 단위로 치환
        - ShiftRows (행의 이동) : 행 단위로 순환 시프트 수행
        - MixColumns (열의 혼합)
            - 열 단위로 혼합(Mixing)
            - 높은 확산을 제공. 마지막 라운드에서 수행 X
        - AddRoundKey : 라운드 키와 XOR 연산

    # -----------------------------------------------------------------------------------------------------

    # 기타 대칭키 암호 알고리즘
    - IDEA (International Data Encryption Algorithm)
        - DES를 대체하기 위한 알고리즘
        - K = 128bitx, M = 64bits
        - 8라운드. 마지막에 한 번 더 키를 적용시킴.
        - DES보다 안전하며, PGP(Pretty Good Privacy)의 암호 알고리즘으로 사용되고 있다.
    - RC5
        - 미국에서 개발, RSA의 Rivest가 개발. (Feistel 구조)
        - 비교적 간단한 연산으로 빠른 암호화와 복호화 기능을 제공
        - 모든 H/W에 적합
    - Skipjack : 음성을 암호화하는데 주로 사용
    - SEED
        - 한국에서 개발된 암호 알고리즘 (Feistel 구조)
        - K = 128bits, M = 128bits, Round = 16
        - 2009년에 키가 256bits로 확장되어 더 강력한 암호화 기능 제공 (SEED-256)
    - ARIA
        - NSRI(국가보안기술연구소, 한국) 주도로 개발된 알고리즘 (SPN 구조)
        - k = 128 / 192 / 256 bits, M = 128bits
    - HIGHT
        - 저전력, 경량화를 요구하는 컴퓨팅 환경에서 기밀성을 제공하기 위해 개발된 알고리즘
        - M = 64bits
    - LEA
        - 128bits 경량 고속 블록 암호 알고리즘
        - 다양한 정보보호 서비스에서 대용량 데이터를 빠르게 처리하거나 스마트폰 보안, 사물 인터넷(IoT) 등 저전력 암호화에 사용 가능

    # -----------------------------------------------------------------------------------------------------

    # Fesitel 구조와 SPN 구조 알고리즘 분류
    - Feistel 구조 : DES, RC5, SEED, LOKI, CAST, Blowfish, MISTY, Twofish, Mars 등
    - SPN 구조 : Rijndael(AES), ARIA, CRYPTON, SAFER, SHARK, Square 등

    # -----------------------------------------------------------------------------------------------------

    # 블록 암호 사용 방식
    - ECB 모드 (Electric CodeBook)
        - 가장 간단하고 빠르며, 병렬 처리 가능
        - 평문 M의 크기가 블록 크기의 배수가 아니라면, padding이 필요.
        - M_A = M_B 이면 C_A = C_B 이다.
        - 블록 암호 (권장 X)
    - CBC 모드 (Cipher Block Chaining)
        - 복호화 시 병렬처리가 가능하지만 암호화 시에는 병렬처리 불가능
        - 첫 번째 평문 블록 암호화시 이전 암호문이 없으므로, 초기 벡터(IV, Initialization Vector)가 사용된다.
        - 암호화 할 때 하나의 평문 에러 발생 시, 이후의 모든 암호문에 에러가 발생한다.
        - 복호화 할 때 하나의 암호문 에러 발생 시, 두 개의 평문에 에러가 발생한다.
        - 블록암호 (Practice Crypto-graphy 권장)
    - CFB 모드 (Cipher FeedBack)
        - 어떤 블록 암호도 스크림 암호(비동기식)로 바꿀 수 있다. --> padding이 필요 없다.
        - 복호화 시에도 암호화 함수 사용.
        - 암호화, 복호화 시 블록 암호의 암호화 함수를 이용
    - OFB 모드 (Output Feedback)
        - 암호문 C에서 손실이 발생하면 그 다음에 오는 평문은 모두 에러가 발생하기 때문에 동기를 새로 맞추어야 한다.
        - IV가 바뀌면 암호문이 모두 바뀜
        - 잡음이 있는 채널상의 스트림 암호에 많이 사용
        - 복호화 시에도 암호화 함수 사용
        - 스트림 암호 (동기식)
    - CTR 모드 (CounTeR)
        - ECB 모드처럼 독립적으로 암호화 / 복호화를 수행
        - 복호화 시에도 암호화 함수 사용
        - ATM 보안, IPsec 보안에 사용
        - 스트림 암호 (Practice Crypto-graphy 권장)
    - 특징
        - ECB 빼고 다 XOR 삽입
        - 노선 가장 빠른 건 ECB
    
    # -----------------------------------------------------------------------------------------------------

    # 비대칭키 암호
    - 대칭키 암호의 키 배송 문제 해결 방법
        - 키 사전 공유
            - 키 관리관(Trusted Authority, TA)이 사전에 사용자들에게 비밀 경로를 통하여 키를 전달
            - 많은 키가 필요. (각 사용자 별로 n-1개, TA = n(n-1) / 2 개)
        - 온라인 키 분배
            - 암호 통신이 필요할 때마다 키 배포 센터(Key Distribution Center, KDC = TA)에서 키를 전달
            - KDC에서 통신하는 사용자의 키로 세션키 K를 암호화해서 전달.
            - 각 사용자는 자신의 키를 복호화해서 세션키 K를 얻어 메시지 / 암호문을 암호화 / 복호화 한다.
        - Diffie-Hellman 키 교환
            - 유한체상의 이산대수 문제(Discrete Logarithm Problem, DLP)를 풀기 어렵다는 사실에 기반
            - 키 교환(계산) 절차 (송신자:A / 수신자:B)
                - A와 B는 매우 큰 소수 p와 q를 선택한다. 
                - p, q : 공개 / x,y : 비밀 / R_1, R_2는 노출돼도 상관없음
                - A는 임의의 큰 수 x를 0 <= x <= p - 1 범위 내에서 선택하고, R_1 = q^x mod p 를 계산
                - B는 임의의 큰 수 y를 0 <= x <= p - 1 범위 내에서 선택하고, R_2 = q^y mod p 를 계산
                - A와 B는 서로에게 R_1, R_2를 전달한다.
                - A는 K = (R_2)^x mod p 를 계산해서 K를 얻는다.
                - B는 K = (R_1)^x mod p 를 계산해서 K를 얻는다.
            - 공격 기법
                - 이산대수 공격 : R_1, R_2 를 도청자가 가로채 x, y를 구하게 되면 K를 알아 낼 수 있다.
                - 중간자 공격(Man-In-The-Middle Attack, MITM) : 인증단계가 없어서 이 공격에 취약
                    - 전자 서명과 공개키 인증서를 이용해서 막을 수 있다.
                    - 국-대-국(STS, Station-To-Station) 프로토콜 : DH에 기반
                    - 세션키를 만들기 위해 공개키 인증서를 이용한 전자서명을 사용하여 MITM 공격을 방지
                - DoS 공격 : DH의 계산이 복잡한 것을 이용하여 공격 대상 서버에 IP 스푸핑 등을 통해 위조한 키 생성 요청을 동시에 다수 요청하여 키 생성 기간으로 인해 서버를 마비시키는 공격
                    - 키 생성 요청자를 확인하기 위한 쿠키(cookie)를 사용함으로써 방지
            - 공개키 암호 사용으로 해결

    # -----------------------------------------------------------------------------------------------------

    # 공개키 암호
    - 대칭키 암호 : 평문을 복잡한 형태로 변환하여 기밀성 유지
    - 공개키 암호 : 수학적으로 해결하기 곤란한 문제를 기반으로 기밀성 유지
    - 대칭키 암호 VS 공개키 암호에서 어떤 것이 더 안전하다고 말할 수 없다.
        - 공개키 암호에서는 암호화키와 복호화키가 분리되어 있다.
        - 두 개의 키는 서로 수학적 관계이기 때문에 각각 별개로 만들 수 없다.
    
    # -----------------------------------------------------------------------------------------------------

    # RSA(Rivest-Shamir-Adleman) 암호시스템
    - 공개키 암호 알고리즘, 세계적으로 널리 인정되는 표준
    - 인수분해 문제(Prime factorization)에 근거
    - 암호화뿐만 아니라 전자서명의 용도로 사용
    - 암호화 / 복호화
        - e : 공개
        - d : 비밀
        - 암호화 : C = M^e mod n
        - 복호화 : M = C^d mod n
    - 키 생성 알고리즘 (공개 : e, n / 비밀 : p,q,d,Φ(n))
        - 서로 다른 소수 p와 q를 선택
        - N = p X q 계산
        - Φ(N) = (p - 1)(q - 1) 계산
        - Φ(N) 보다 작고, Φ(N)과 서로소인 정수 e를 찾는다.
        - de = 1(mod Φ(N)) 을 만족하는 정수 d를 구한다.
            - 공개키 : (e, n) / 비밀키 : (d, n)
    - p, q, e, d 조건
        - p와 q는 거의 같은 크기이고 최소 512bits가 되어야 한다. -> N은 최소 1024bits
        - p - 1 과 q - 1 은 큰 소인수를 갖는다.
        - p - 1 과 q - 1 의 최대공약수는 작은 수이다.
        - d와 n은 거의 같은 크기이다.
    - RSA 알고리즘의 안정성은 p와 q를 구해 내는 것에 달려있다.
    - 최적 비대칭키 암호 패딩 (OAEP, Optimal Asymmetric Encryption Padding)
        - RSA에서 짧은 메시지는 짧은 메시지 공격에 의해 암호문을 위험에 빠뜨리게 된다.
        - 의미 없는 padding을 메시지에 붙여 공격 작업을 어렵게 한다.
    - 공격 기법
        - 수학적 공격(소인수 분해 공격) : 두 개의 소수 곱을  신수분해 하려는 시도
        - 타이밍 공격(시간 공격) : 복호화 알고리즘 실행 시간에 의존
        - 선택 암호문 공격(CCA)
            - 임임의 데이터 송신 시 그것을 암호문으로 간주하고 회신해주는 것을 이용한 공격.
            - OAEP로 방지할 수 있다.
    
    # -----------------------------------------------------------------------------------------------------

    # Rabin 암호시스템
    - 합성수 모듈러에 관하여 제곱근을 찾기 어렵다는 사실로부터 안정성을 얻는다. (인수분해 문제)
    - 암호화 과정은 오직 한 번의 곱셈으로 매우 빨리 수행된다.
    - Rabin 암호시스템의 복잡도는 큰 수 n을 두개의 소수의 곱으로 소인수분해하는 수준의 복잡도와 같다.
    - p와 q의 크기가 충분히 크다면 RSA만큼 안전하다.

    # -----------------------------------------------------------------------------------------------------

    # ElGamal 암호시스템
    - 이산대수 문제에 근거
    - 암호화과정에서 암호문의 길이는 평문의 약 2배가 됨.
    - 때문에, 많은 메모리 공간이 필요, 전송속도 느려짐.

    # -----------------------------------------------------------------------------------------------------

    # 타원 곡선 암호(ECC, Elliptic Curve Cryptosystem)
    - 타원 곡선(Elliptic Curve)이라는 이론에 근거 (타원곡선 군에서의 이산대수 문제)
    - RSA보다 키의 길이를 줄이면서도 동일한 성능을 제공하여 전자상거래의 핵심 기술로 주목받고 있음
    - H/W와 S/W로 구현하기가 용이
    - 메모리와 처리능력이 제한된 응용분야(스마트카드, 무선통신 단말기 등)에 효율적

    # -----------------------------------------------------------------------------------------------------

    # 하이브리드 암호시스템
    - 대칭키 암호의 기밀성 + 공개키 암호로 키 배송 문제 해결
    - 공개키 암호 문제점 2가지
        - 대칭키 암호에 비해 처리속도가 많이 느리다. -> 하이브리드 암호시스템
        - MITM 공격에 약하다. -> 공개키에 대한 '인증'이 필요
    
    # -----------------------------------------------------------------------------------------------------

    # 인수분해 / 이산대수 근거 암호시스템 분류
    - 인수분해 문제 : RSA, Rabin **R들어가면 인수분해**
    - 이산대수 문제 : Diffie-Hellman, ElGamal, ECC, DSS

    # -----------------------------------------------------------------------------------------------------

    # 해시함수와 응용
    - 일방향 해시함수
        - 해시함수 : 임이의 길이 m을 갖는 메시지 M을 입력으로 해서 고정된 길이 n을 갖는 해시 값 또는 해시 코드라 불리는 값을 출력하는 함수
        - 충돌이 존재. 해시 값 한 개에 여러 메시지를 가질 수 있다.
        - 일방향 해시함수 = 메시지 다이제스트 함수 = 암호학적 해시 함수
        - 출력되는 해시 값 = 메시지 다이제스트 = 핑거프린트
    - 특징
        - 임의 길이가 메시지로부터 고정 길이의 해시 값을 계산
        - 해시 값을 고속으로 계산할 수 있다.
        - 일방향성을 갖는다. : 해시 값으로부터 메시지를 구할 수 없다.
        - 메시지가 다르면 해시 값도 다르다.
    - 랜덤 오라클 모델(Random Oracle Model)
        - 해시함수에 대한 이상적인 수학적 모델
        - 임의의 길이를 갖는 메시지에 오라클은 난수로 생성된 고정된 길이의 메시지 다이제스트를 생성, 제공
        - 이미 다이제스트가 존재하는 메시지가 주어지면 오라클은 저장되어 있던 다이제스트 제공
        - 새로운 메시지에 대해서는 이미 생성한 다이제스트와는 다른 다이제스트를 생성
    - 공격 기법
        - 무차별 공격 : 약한 충돌 내성을 깨고자 하는 공격
        - 일치블록 연쇄공격 : 사전에 해시 값을 다양하게 생성 후 공격하고자 하는 메시지의 해시 값과 같은 것을 찾는 공격
        - 중간자 연쇄공격 : 전체 해시 값이 아닌 해시 중간 결과에 대한 충돌 쌍을 찾는다.
        - 고정점 연쇄공격 : 메시지 블록과 연쇄변수 쌍을 얻어 연쇄변수가 발생하는 특정한 점에 임의의 동등한 블록들을 메시지 중간에 삽입해도 전체 해시 값이 변하지 않는다.
        - 차분 연쇄공격 : 압축함수의 입출력 차이를 조사하여 0의 충돌쌍을 찾아내는 공격
    
    # 해시함수의 보안 요구사항
    - 역상 저항성
        - y = h(M)을 만족하는 입력 값 M을 찾는 것이 매우 힘들어야 된다.
        - 안전성, 역함수 계산 방지
    - 두 번째 역상 저항성 (= 약한 충돌 내성 = 강 일방향성)
        - y = h(M) = h(M'), M != M' 을 만족하는 다른 입력 값 M'을 찾는 것이 매우 힘들어야 한다.
        - 안전성, 역함수 계산 방지
    - 충돌 저항성 (= 강항 충돌 내성 = 충돌 회피성)
        - y = h(M) = h(M')을 만족하는 임의의 두 입력 값 M, M'을 찾는 것이 매우 힘들어야 한다.
        - 안전성, 내부부정 방지
        - 충돌 저항성은 두 번째 역상 저항성을 보장
    
    # -----------------------------------------------------------------------------------------------------

    # 키가 없는 해시함수
    - 다이제스트(digest) : 해시 함수에 의해 생성된 고정된 길이의 데이터 요약본
    - 메시지 다이제스트(Message Digest)
        - MD2 -> MD4 -> MD5
        - MD5는 메시지를 512bits로 된 블록으로 나누고 128bits  다이제스트를 출력한다. 라운드 수는 64(14 * 4R)
        - 128bits 메시지 다이제스트는 충돌 공격에 내성을 갖기에는 길이가 너무 짧다고 알려진다.
        - 내부 구조에 대한 약점이 발견되고, 생일 공격에 노출되었다.
    - SHA(Secure Hash Algorithm)
        - MD4 해시함수에 기초해서 만들어짐. MD5보다 느리지만 조금 더 안전.
        - SHA-160 (SHA-1) : 메시지를 512bits 블록으로 나누고 160bits의 다이제스트를 출력한다. 라운드 수는 80(20 * 4R)
        - SHA-512 (SHA-2) : 메시지를 1024bits 블록으로 나누고 512bits의 다이제스트를 출력한다. 메시지의 길이는 2^128bits를 넘지 않는다.
    - RIPEMD-160 : 메시지를 512bits 블록으로 나누고 160bits의 다이제스트를 출력한다.
    - Tiger : 64bits 시스템에서 해시 함수를 수행하기 위해 설계. MD5, SHA-1보다 속도가 빠르다.
    - HAVAL : 메시지를 1024bits 블록으로 나누고 128/160/192/224/256bits의 다이제스트를 출력한다.
    - HAS160 : 메시지를 512bits 블록으로 나누고 160bits의 다이제스트를 출력. 한국형 전자서명 표준에 사용할 목적으로 개발됨.
    - 변경 감지 코드(MDC, Modification Detection Code)
        - 메시지의 무결성을 보장하는 메시지 다이제스트
        - 수신자는 메시지로부터 새로운 MDC를 생성하고, 송신자에게 받은 MDC와 비교하여 해당 메시지가 변경되지 않았다는 것을 보장해준다.
    
    # 키를 사용하는 해시함수, MAC
    - 무결성을 확인하고, 메시지에 대한 인증을 하는 기술
    - 대칭키 암호 사용. (MAC 알고리즘으로 블록 암호나 해시 함수에 기반을 둠)
    - 대칭키 암호를 사용함으로써, 키 배송 문제가 생긴다.
    - 축소 MAC : 해시 과정이 두 단계로 이루어져 있음. (키도 두 번 사용)
    - HMAC : 앞의 H는 해시함수를 의미하며, SHA-1과 같은 일방향 해시함수를 이용하여 MAC를 구성
    - CBC-MAC : 블록 암호 모드인 CBC모드와 유사한 방법
    - CMAC : CBC-MAC와 같은 종류의 데이터 인증과 무결성을 제공하지만, 조금 더 안전
    - CCM(Counter with CBC-MAC)
        - CTR 모드와 CBC-MAC을 통합.
        - AES 암호 알고리즘, CTR 모드, CBC-MAC 인증 알고리즘으로 구성
    - GCM mode : CTR 모드에 인증 기능을 추가한 모드
    - 재전송 공격
        - MAC 값을 도청해서 저장해둔 뒤 저장해둔 MAC 값을 반복해서 송신하는 공격
        - 보안 대책으로 순서 번호, 타임스탬프, 비표(nonce), 시도/응답이 있다.
    
    - MAC가 해결하지 못하는 문제
        - 제 3자에 대한 증명 : 두 사람 사이에서는 상대방이 MAC를 계산하였다고 말할 수 있지만, 제 3자에게 MAC 값을 누가 계산했는지 증명할 방법이 없다. -> 전자서명으로 증명 가능
        - 부인 방지 -> 역시 전자서명으로 부인 방지가 가능해진다.


    # -----------------------------------------------------------------------------------------------------
    
    # 전자서명과 PKI
    - 전자서명 서비스
        - 공개키 암호방식을 이용한 공개키 서명 방식 : 누구나 검증 가능하여, 서명 생성 및 검증이 간편
        - 관용 암호방식을 이용한 중재 서명 방식 : 서명 생성과 검증을 제3자가 중재. 서명할 때마다 제3자의 참여가 있어야 함.
    - 메시지 인증 : 수신자 B는 받은 메시지가 송신자 A로부터 왔다는 것을 알 수 있다.
    - 메시지 무결성 : 메시지가 변경되면 서명도 변경된다. (해시함수, 공개키)
    - 부인방지 : 신뢰받는 제 3자로부터 검증받을 수 있다.
    - 공개키 알고리즘을 사용하면 기밀성을 보장할 수 있다.
    - 암호화 시스템에서는 수신자의 개인키와 공개키가 사용되고, 전자서명에서는 송신자의 개인키와 공개키가 사용된다.
    - 전자서명의 주요 기능
        - 위조 불가 : 합법적인 서명자만이 전자서명을 생성할 수 있어야 한다.
        - 서명자 인증 : 전자서명의 서명자를 누구든지 검증할 수 있어야 한다.
        - 부인방지 : 서명자는 서명행위 이후에 서명한 사실을 부인할 수 없어야 한다.
        - 변경 불가 : 서명한 문서의 내용을 변경할 수 없어야 한다.
        - 재사용 불가 : 전자문서의 서명을 다른 전자문서의 서명으로 사용할 수 없어야 한다.

    # 전자서명 구조
    - RSA 전자서명 구조
        - 전자서명 구조에서는 개인키와 공개키의 역할이 바뀐다.
        - 암호화에서는 수신자의 키를 이용했지만, 전자서명에서는 송신자의 개인키와 공개키를 이용한다.
    - ElGamal 전자서명 구조 : ElGamal 암호시스템과 동일한 키를 사용하지만 알고리즘은 다르다.
    - Schnorr 전자서명 구조 : ElGamal 기반이지만 서명의 크기를 줄인 새로운 구조
    - DSS(Digital Signature Standard)
        - ElGamal 전자서명을 개량한 방식. (이산대수 문제)
        - 오직 전자서명 기능만을 제공하도록 설계되었고 서명과 검증에 소요되는 계산량을 줄임
    - 타원곡선 전자서명 구조(ECDSA, Elliptic Curve DSA) : 짧은 비트 길이로 인해 짧은 처리 시간에 짧은 서명 생성이 가능

    # 전자서명 방식
    - 복원형 전자서명
        - 기존 공개키 암호방식을 이용하여 별도의 전자서명 프로토콜이 필요 없음.
        - 메시지를 일정 크기 블록으로 나누어, 그 각각의 블록에 서명을 해야 하므로 시간 소요 증가
        - 실제로는 사용되지 않는다.
    - 부가형 전자서명
        - 메시지를 해시하여 나온 다이제스트에 한 번의 서명 생성 과정만이 필요하므로 효율적이다.
        - 전송량이 조금 늘어나지만 실제로 많이 사용되는 방법이다.
    
    # 특수 전자서명
    - 공개키 방식을 이용한 전자 서명은 검증하는 키가 공개되어 있어서 서명의 검증을 누구나 할 수 있는 문제점이 있다.
    - 부인방지 전자서명 : 자체 인증 방식을 배제시키고 서명 검증할 때, 서명자의 도움이 있어야 검증이 가능한 방식
    - 의뢰 부인방지 서명 : 신뢰하는 제 3자가 서명을 검증해주는 방식
    - 수신자 지정 서명 : 지정한 검증자만이 서명을 검증할 수 있고, 필요시 제 3자에게 그 서명이 서명자에 의해 자신에게 발행된 명임을 증명할 수 있게 하는 방식
    - 위임 서명 : 부재 중 자신을 대리해서 서명을 할 수 있는 방식
    - 은닉 서명(Blind Digital Signature) : 서명문의 내용을 숨기는 방식, 익명성을 유지할 수 있음.
    - 다중 서명 : 동일 전자문서에 여러 명이 서명하는 방식

    # 전자투표 시스템
    - 요구사항
        - 완전성 : 투표 결과의 정확한 집계
        - 익명성 : 투표 결과로부터 투표자 구별 불가
        - 건전성(강건성) : 부정 투표자에 의한 선거 방해가 없어야 한다.
        - 이중투표방지(재사용 불가) : 정당한 투표자는 단 1회만 투표 허용
        - 정당성 : 투표에 영향을 미치는 것이 없어야 한다.
        - 적임성 : 투표에 없는 자의 투표 행위 금지
        - 검증 가능 : 투표 결과를 누구나 확인하여 검증해볼 수 있다.(투표 결과 위조 불가능)
    - 방식 (PSEV - 키오스크 - REV)
        - PSEV 방식 : 기존 선거 방식 + 전자
        - 키오스크(kiosk) 방식 : PSEV 방식과 유사하지만 공공장소에 설치, 관리자 없음
        - REV 방식 : 어디서든 투표 가능. 비밀투표 침해가능성 높음
    
    # 전자입찰 시스템
    - 요구사항
        - 독립성 : 각 구성요소는 독자적인 자율성을 보장받아야 함
        - 비밀성 : 네트워크상의 개별 정보는 누구에게도 노출되지 않아야 함
        - 무결성 : 입찰 시 입찰자 자신의 정보를 확인 가능하게 하여, 누락 및 변조 여부 확인이 가능해야 함
        - 공평성 : 입찰이 수행될 때 모든 정보는 공개되어야 함
        - 안전성 : 각 입찰 참여자 간의 공모 방지
    
    # -----------------------------------------------------------------------------------------------------

    # PKI 개념
    - 공개키 알고리즘을 위한 키 관리 구조
    - 제공 서비스 : 기밀성, 무결성, 인증, 부인방지, 접근제어
    - 일방향 해시함수 -> MAC -> 전자서명 -> PKI 의 흐름으로 이어진다.

    # PKI 구성요소
    - 크게 인증기관, 검증기관, 등록기관, 저장소, 사용자로 구성되어 있다.
    - 인증기관(CA, Certification Authority) : 인증정책 수립, 인증서 관리, 다른 CA와의 상호 인증
        - 정책승인기관(PAA, Policy Approving Authority)
            - 루트 인증기관으로, PKI 전반에 사용되는 정책을 생성, 수립
            - 하위 기관들의 정책 감사
        - 정책인증기관(PCA, Policy Certification Authority)
            - PPA 하위 계층, 하위 CA, 사용자들의 정책 수립
            - CA의 공개키를 인증하고 인증서, 인증서 폐지 목록 등을 관리
        - 인증기관(CA)
            - PCA 하위 계층.
            - 사용자/등록기관의 요청에 공개키 인증서를 발행/폐지
            - 사용자에게 자신의 공개키와 상위 기관의 공개키를 전달
    - 검증기관(VA, Validation Authority)
        - 인증서의 유효성 여부 / 관련 거래의 유효성 여부 등을 확인시켜줌.
        - 적절한 인증서 검증 기능이 없다면, 보안성이 떨어진다.
        - CA에서 직접 운영가능
    - 등록기관(RA, Registration Authority)
        - 사용자와 CA가 원거리에 있는 경우, 사용자와 CA 사이에 RA를 두어 사용자의 인증서 신청 시 CA 대신 사용자의 신분 소속등을 확인
        - 선택적 요소. RA가 없으면 CA가 RA의 기능을 대신 수행할 수 있다.
    
    # PKI 형태
    - 계층 구조
        - 최상위에 루트 CA가 존재하고, 그 밑으로 하위 CA가 계층적으로 존재하는 트리 구조.
        - 상위 CA가 하위 CA에 인증서를 발행하고, 하위 CA는 상위 CA의 인증정책에 영향을 받는다.
        - 루트 CA 간에 상호인증은 허용하지만, 하위 CA 간에 상호인증은 불가능.
        - 정부 같은 관료조직에 적합, 협동업무 관계에는 부적합
        - 인증경로 탐색이 용이하고, 모든 사용자가 최상위 CA의 공개키를 알고 있어서 검증이 용이
        - 최상위 CA에 집중되는 오버헤드가 발생
        - 최상위 CA의 비밀키 노출이 되면 피해가 막대하다.
    
    # -----------------------------------------------------------------------------------------------------

    # 네트워크 구조
    - 각각의 CA들이 자신의 인증정책에 따라 독립적으로 존재하는 형태
    - 모든 상호인증이 허용되면 상호인증의 수가 대폭 증가
    - 유연하고 인증경로 단순하여 실질적인 업무관계에 적합
    - CA의 비밀키가 노출이 되도 피해가 적다.
    - 인증경로 탐색이 복잡하고, 정책 수립과 적용이 어려움

    # -----------------------------------------------------------------------------------------------------

    # 인증서 표준 규격 X.509
    - 공개키 인증서 (PKC, Public Key Certificate)
        - 해당키가 특정인의 것이라는 것을 보증해주는 것
        - 개인정보, 소유자의 공개키가 들어있고, CA의 개인키로 전자서명 되어있다.
    
    # -----------------------------------------------------------------------------------------------------

    # X.509 v3 인증서 프로파일
    - 버전(Version) : 필수 : X.509의 버전
    - 일별번호(Serial Number) : 필수 : CA에 의해 인증서에 부여되는 유일한 번호. (발행자이름과 일렬번호로 인증서를 유일하게 구분할 수 있어야 한다.)
    - 서명 알고리즘 식별자(Signature Algorithm ID) : 필수 : CA가 인증서를 서명하기 위한 알고리즘과 알고리즘 식별자를 포함. 이 정보는 끝부분 서명 필드에도 포함되어 있다.
    - 발행자 이름(Issuer name) : 필수 : 인증서 발행자(보통 CA)의 이름
    - 유효기간(Validity period) : 필수 : 인증서 유효기간의 시작날짜와 종료날짜
    - 주체 이름(Subject name) : 필수 : 사용자(피발급자)의 이름, 상위 CA가 하위 CA에게 인증서를 발행하는 경우 이 필드에는 CA의 이름이 된다.
    - 주체의 공개키 정보(Subject Public Key) : 필수 : 사용자의 공개키, 관련 알고리즘
    - 발행자 유일 식별자(Issuer Unique ID) : 선택 : 발행자나 사용자의 이름이 중복되는 경우 이를 구별하기 위한 수단
    - 주체 유일 식별자(Subject Unique ID) : 선택 : 주체를 유일하게 구별하는 데 사용
    - 확장(Extensions) : 선택 : 발행자가 인증서에 추가적으로 사적인 정보를 넣을 수 있는 필드
    - 서명(Signature) : 필수 : 인증서에 대한 서명 값이 들어있는 필드 나머지 전체 필드를 보호하는 역할을 한다. 다른 필드 전체를 해시해서 나온 해시 값을 CA의 개인키로 암호화한 값이 들어간다.

    # X.509 인증서 폐지 목록
    - 인증서 폐지 목록(CRL, Certificate Revocation List)은 CA의 저장소 또는 디렉터리에 저장되어 신뢰 사용자가 언제든지 이 목록을 검색할 수 있어야 한다.
    - CRL 내의 폐기된 인증서들은 인증서 일렬번호에 의해서 확인할 수 있다.
    - 인증서 폐지 사유
        - 사용자의 개인키가 노출되었거나 훼손된 것으로 판단되는 경우
        - CA가 사용자를 더 이상 인증해줄 수 없을 경우
        - CA의 개인키가 노출되었거나 훼손된 것으로 판단되는 경우
    - 온라인 인증서 상태 검증 프로토콜(OCSP, Online Certificate Status Protocol)
        - 실시간으로 인증서 상태를 확인할 수 있는 프로토콜
        - 백그라운드에서 자동으로 수행하며, CA에 의해 관리되고 있는 CRL을 검사
        - OCSP 클라이언트, OCSP 서버, 인증 서버로 구성
    - 인증서 관리 프로토콜(CMP, Certificate Management Protocol) : PKI 환경에서 인증서 관리 서비스를 제공하기 위한 PKI 실체들(이용자, CA, RA 등) 간의 통신 프로토콜

    # -----------------------------------------------------------------------------------------------------

    # 키, 난수
    - 세션키 : 통신 때마다 한 번만 사용되는 키
    - C 마스터키(Master key) : 반복적으로 사용되는 키
    - CEK(Contents Encrypting Key) : 사용자가 이용하는 콘텐츠를 암호화하는 키
    - KEK(Key Encrypting Key) : 키를 암호화하는 키

    # 솔트(Salt)
    - 키(KEK)를 만들 때 패스워드와 함께 일방향 해시함수에 입력된다.
    - 사전공격을 막기 위해 존재
    - KEK를 만들 때 솔트를 사용하면 KEK 후보가 솔트의 비트 길이만큼 늘어난다.
    - 난수의 성질 : 무작위성 - 예측 불가능성 - 재현 불가능성
    - 의사난수 생성기 : 난수(의사난수)를 생성하는 S/W

    # -----------------------------------------------------------------------------------------------------





PART 3. 접근통제
- 3.0 접근통제 
    # 개요
    - 접근제어 : 허가되지 않은 자원의 사용과 허가되지 않은 방법을 통한 자원 사용을 제어하는 것
    - 주체(행위자), 접근(주체의 활동), 객체(제공자)
    - 접근 통제 절차 3+1 가지
        - 식별 : 본인이 누구라는 것을 시스템에 밝히는 행위(ID, 계정번호, 메모리카드)
        - 인증 : 주체의 신원을 검증하기 위한 증명(패스워드, 스마트카드, 생채인증)
        - 인가 : 인증된 주체에게 접근을 허용하고 특정 업무를 수행할 권리를 부여(접근제어목록, 보안등급)
        - 책임추적성 : 시스템에 인가된 주체가 시스템에 어떤 행위를 하고 있는지 기록
    - 기본 원칙 : 직무 분리, 최소 권한 등

    # -----------------------------------------------------------------------------------------------------

    # 지식 기반 인증(What you know)
    - 장점
        - 다양한 분야에서 사용
        - 검증이 확실
        - 비용이 저렴함
        - 사용 편리
    - 단점
        - 소유자의 분실 가능성
        - 공격자의 추측 가능
        - 사회 공학적 공격에 취약
        - 사용자의 관리 부주의로 인한 노출
    
    # -----------------------------------------------------------------------------------------------------

    # 패스워드(Password)
    - 고정된 패스워드
        - 방법1 : ID/PW를 DB에 그대로 저장
        - 방법2 : 패스워드를 해시한 값을 저장
        - 방법3 : 패스워드에 솔트(Salt)를 붙여 해시한 값을 저장
    - 일회용 패스워드(OTP, One-Time Password)
        - 오직 한번만 사용되는 패스워드이기 때문에 도청이나 도난이 무의미해짐
        - 방법1 : 사용자와 시스템이 PW 목록에 대해 합의하고, 그 패스워드들은 오직 한번만 사용한다.
        - 방법2 : 사용자와 시스템이 PW를 순차적으로 업데이트하기로 합의한다.
        - 방법3 : 사용자와 시스템이 해시함수를 이용하여 순차적으로 업데이트하기로 합의한다.
    - 패스워드의 안정성과 문제점
        - 패스워드의 길이가 길어질수록, 패스워드의 사용기간이 짧을수록, 사용빈도가 낮을수록 패스워드를 추측하기 어렵다.
        - 크래킹 툴(NTCrac, John the ripper)과 같은 소프트웨어로 크랙하기 쉽다.
    
    # -----------------------------------------------------------------------------------------------------
    
    # 시도-응답(Challenge-Response) 개인 식별 프로토콜
    - 도청이 가능한 환경에서 안전
    - 대칭형 암호와 공개키 암호에 기반
    - 어떤 실체가 자신의 신분을 다른 실체에게 증명하기 위하여 자기 자신만이 소유하고 있는 어떤 비밀정보를 자신이 알고 있다는 사실을 간접적으로 보여주는 프로토콜
    - 일방향 개인 식별 프로토콜 : 서버 또는 클라이언트 중에 어느 한 대상을 식별하는 프로토콜
    - 상호 개인 식별 프로토콜 : 상호간에 대상을 식별하는 프로토콜
    
    # -----------------------------------------------------------------------------------------------------

    # 영지식(zero knowledge) 개인 식별 프로토콜
    - 시도-응답 개인 식별 프로토콜이나 패스워드를 이용한 개인 식별은 클라이언트와 서버가 비밀 정보를 동시에 공유하고 있어야 하기 때문에, 클라이언트가 서버를 신뢰하지 못하는 상황에서 유용
    - 자신의 비밀정보를 제공하지 않고 자신의 정당한 신분만을 밝힘으로써 식별되는 유형의 프로토콜

    # I-PIN(Internet Personal Identification Number)
    - 주민번호 대신에 ID와 PW로 대체하는 수단
    - 이용효과
        - 주민번호 유출예방
        - 본인확인 강화

    # -----------------------------------------------------------------------------------------------------

    # 소유 기반 인증
    - 장점
        - 일반적임
        - 입증된 기술(신용카드)
        - 생체 인식 방식보다 경제적
    - 단점
        - 물리적 파손
        - 소유물이 없을 경우 인증이 어려움
        - 복제 가능
        - 사회 공학적 공격
        - 자산 관리 기능 요구
    - 메모리 카드(토큰) : 정보를 저장할 수 있지만 정보를 처리할 수 없다.
    - 스마트카드 : 정보를 저장/처리할 수 있다.
    
    # -----------------------------------------------------------------------------------------------------

    # 일회용 패스워드(OTP, One-Time Password)
    - OTP용 프로그램에서 사용자 패스워드와 OTP 생성용 입력 값을 입력하면 암호 알고리즘을 사용해서 OTP를 생성하는 사용자 인증 방법.
    - OTP는 단말장치로 주로 구현돼서 소유기반으로 분류한다.
    - 사회 공학적 공격에 대처 가능하며 일정 시간마다 패스워드를 변경한다.
    - 휴대폰을 통한 인증으로 사용자의 편리성 및 안정성을 확보

    # 질의응답 방식
    - 인증서버에서 질의 값을 전송하고 사용자가 질의 값을 입력해 응답 값을 생성해 응답 값을 전송하는 방식
    - 구조가 간단하며 OTP 생성 매체와 인증서버 간 동기화가 필요 없다.
    - 사용자가 질의 값을 직접 입력해야 하는 번거러움이 있고, 인증 서버에서는 같은 질의 값이 생성되지 않도록 관리해야 한다.

    # 시간과 이벤트 동기화 방식
    - 토큰장치와 인증서비스는 반드시 동일한 비밀키를 공유하여 암/복호화에 사용한다.
    - 시간 동기화 방식 : 토큰장치와 비밀키에 나타나는 시간 값은 OTP를 생성하는데 사용
    - 이벤트 동기화 방식 : 사용자가 토큰장치의 버튼을 누르면 다음 인증 값이 나타남
    - 이벤트 동기화 방식은 시간 동기화 방식에 비해 동기화되는 기준 값을 수동으로 조작할 필요가 적어 사용이 간편함.
    - 질의응답 방식에 비해 호환성이 높음
    - OTP 생성 매체와 인증서버의 시간 정보/계수기 값이 동기화되어 있어야 함
    
    # -----------------------------------------------------------------------------------------------------

    # S/KEY 방식
    - 유닉스 계열 OS에서 인증에 사용되는 해시 체인 기반의 방식
    - 클라이언트에서 정한 임의의 비밀키를 서버에서 받아 이 비밀키를 첫 번째 값으로 해시 체인 방식으로 이전 결과값에 대한 해시 값을 구하는 작업을 n번 수행한 뒤, 이 n개의 OTP를 서버에 저장

    # -----------------------------------------------------------------------------------------------------

    # 개체(생물학적) 특성 기반 인증
    - 장점
        - 사용하기 쉬움
        - 분실, 손실, 도난 될 수 없다.
        - 위조가 어렵다.
        - 대여 불가능
    - 단점
        - 잘못 판단할 가능성 존재
        - 관리가 어려움
        - 인증을 위한 임계치 설정이 어렵다
    - 생체인증 기술 평가항목 : 보편성, 유일성, 지속성, 획득성, 성능, 수용성, 반기만성
    - 생체인증의 정확도
        - FRR(False Rejection Rate, 오거부율), FAR(False Acceptance Rate, 오인식률)
        - FRR : 인식되어야 할 사람이 얼마나 시스템에 의해서 인식이 되지 않았는지에 대한 값
        - FAR : 인식되어서는 안 될 사람이 얼마나 시스템에 의해서 인식이 되는지에 대한 값
        - 보안성 강화 : FRR 증가 / FAR 감소
        - 사용자의 편의성 : FAR 증가 / FRR 감소

    # -----------------------------------------------------------------------------------------------------

    # 통합인증체계(SSO)
    - SSO(Single Sign On) : 한 번의 시스템 인증을 통하여 접근하고자 하는 다양한 시스템에 재인증 절차 없이 접근할 수 있도록 하는 통합 로그인 솔루션이다.
    - 패스워드 분실/망각 가능성 감소
    - 관리의 간편함, 보안수준의 향상
    - 장점
        - 사용자 편의성 증가, 보안성 강화
        - 중앙 집중 관리를 통한 효율적 관리(운영비용 감소)
    - 단점
        - SSO서버 침해 시 모든 서버의 보안 침해 가능 (단일 실패 지점)
        - 자원별 권한관리 미비
    - 엑스트라넷 접근 관리(EAM, Extranet Access Management) : 인트라넷, 엑스트라넷 및 일반 클라이언트/서버 환경에서 자원의 접근 인증과 이를 기반으로 자원에 대한 접근 권한 부여/관리하는 통합 인증 관리 솔루션
    - 식별/접근 관리(IAM, Identity and Access Management) : ID와 패스워드를 종합적으로 관리해주는 역할 기반의 계정 관리 솔루션. EAM을 확장/보완한 솔루션

    # -----------------------------------------------------------------------------------------------------

    # 커버로스(Kerberos)
    - 인증 프로토콜이자 KDC(키 배포 센터)이다.
    - 개방된 네트워크 내에서 서비스 요구를 인증하기 위해 대칭키 암호기법에 바탕을 둔 티켓 기반 인증 프로토콜.
    - 분산 환경을 위한 SSO이며, 기업 접근 통제를 위한 확장성, 투명성, 안정성, 보안을 제공

    # 커버로스 구성요소
    - KDC : 커버로스의 핵심
    - AS : 실질적으로 인증을 수행하는 KDC의 부분 서비스
    - TGS : 티켓을 부여/분배하는 KDC의 부분 서비스
    - 티켓 : 사용자에 대해 신원과 인증을 확인하는 토큰

    # 커버로스 구성
    - 커버로스는 모든 사용자의 패스워드를 알고 있고, 중앙집중식 DB에 그 패스워드를 저장하고 있는 인증서버(AS)를 이용
    - AS는 각 서버와 유일한 비밀키를 공유
    - TGS는 AS에게 인증 받은 사용자에게 티켓을 발행
    - 사용자가 새 서비스를 요청할 때마다 자신을 인증하는 티켓을 이용하여 TGS에 접속, TGS가 해당 서비스에 대한 티켓 발행
    - 사용자는 서비스 승인 티켓을 보관하고 필요할 때마다 티켓을 사용하여 서버에 인증시킨다.

    # 커버로스의 취약성
    - KDC는 단일 실패 지점이 될 수 있으므로, 이중화 구성이 필요
    - 비밀키는 사용자의 워크 스테이션에 임시로 저장되어, 공격자에게 탈취될 수 있다.
    - 패스워드 추측 공격에 취약

    # 커버로스 버전4, 버전5 차이
    - 버전4 : DES 알고리즘을 사용해야 했지만 
        - 버전5 : 모든 대칭키 알고리즘을 사용할 수 있다.
    - 버전4 : 인터넷 프로토콜 주소를 사용해야 했지만 
        - 버전5 : 어떤 유형의 네트워크 주소를 사용할 수 있다.
    - 버전4 : 티켓 유효기간의 한게가 있었지만 
        - 버전5 : 유효기간의 한계가 없어 수명이 더길고 갱신도 가능하다.

    # -----------------------------------------------------------------------------------------------------

    # 세사미(SESAME)
    - 커버로스의 기능을 확장하고 약점을 보완하기 위해 개발된 SSO 기술
    - 커버로스는 대칭키 기반이지만 세사미는 비대칭 및 대칭키 암호화 기술에 기반한다.
    - 커버로스에 티겟이 있으면, 세사미에는 PAC(Privileged Attribute Certificate)가 있다.

    # -----------------------------------------------------------------------------------------------------
    
    # 접근통제 보안 모델
    # 강제적 접근통제(MAC, Mandatory Acccess Control)
    - 각 주체와 객체의 보안등급을 비교하는 것에 기반
    - 관리자만이 접근제어의 규칙을 설정, 변경할 수 있다. (중앙집중형 보안관리)
    - 사용자의 의도와는 관계없이 의무적으로 접근을 제어한다.
    - 모든 MAC 모델은 벨라파듈라(BLP) 모델을 근간으로 하고 있다.
    - 구성 : 주체 등급(사용자, 주체의 보안레벨) / 객체 등급(데이터, 객체의 보안레벨)
    - 장점
        - 매우 엄격한 보안, 중앙집중식 관리
        - 모든 객체에 대한 관리가 용이
    - 단점
        - 구현, 운영이 복잡
        - 상업적인 환경에 부적합

    # 임의적 접근통제(DAC, Discretionary Access Control)
    - 접근하고자 하는 주체의 신분에 따라 접근권한을 부여하는 방법
    - 객체의 소유자가 접근여부를 결정한다. (분산형 보안관리)
    - 하나의 주체마다 객체에 대한 접근 권한을 부여해야 함
    - 장점
        - 구현이 쉽다.
        - 권한 변경이 유연함
    - 단점
        - 데이처(객체)의 의미에 대해 지식이 없음
        - 신분(ID) 도용 시 통제 방법이 없음
        - 트로이 목마 공격에 취약
    - 접근제어 행렬(Access Control Matrix)
        - 주체를 행, 객체를 열로 구성하고 해당 셀에 주체가 객체에 수행할 수 있는 접근 권한을 기록하여 관리
        - 효과적인 권한 부여 정책을 정의 가능하지만 주체와 객체의 수가 많아질 경우 행렬의 크기가 커져 관리가 어렵다.
    - 자격 목록(Capability List, Capability Tickets, Capability Table)
        - 주체의 관점에서 객체에게 권한을 부여
        - 콘텐츠의 보안성이 보장받지 못하는 분산환경에서 사용
        - 커버로스가 자격목록의 한 예이다.
    - 접근제어 목록(ACLs, Access Control Lists)
        - 객체의 관점에서 주체에게 권한을 부여
    
    # 역할기반 접근통제(RBAC, Role-Based Access Control)
    - 주체와 객체 사이에 역할을 두어 역할에 따라 접근통제
    - MAC와 DAC의 단점을 보안환 기법이다. (Non-DAC)
    - 주체, 객체에 접근권한을 할당하는 것이 아닌 역할에 접근권한을 할당한다.
    - 정책을 자주 변동하지 않고도 정책관리를 용이하게 할 수 있다.
    - 장점
        - 관리자에게 편리한 관리능력 제공
        - DAC에 비해 유연성은 떨어지나, 일관성 있는 접근제어가 용이
        - 최소권한의 원칙, 직무분리의 원칙, 데이터의 추상화
    
    # 벨라파듈라 모델(BLP, Bell-LaPadula Confidentiality Model)
    - 기밀성을 강조한 MAC 모델
    - 보안 규칙
        - 상급 보안 계층 / 읽기 : X / 쓰기 : O / 읽기/쓰기 : X
        - 할당된 보안 계층 / 읽기 : O / 쓰기 : O / 읽기/쓰기 : O
        - 하급 보안 계층 / 읽기 : O / 쓰기 : X / 읽기/쓰기 : X
    - 단순 보안 속성(simple security property, ss-property) : 상향 읽기 X / 하향 읽기 O
    - 성형(*) 보안 속성(*-property) : 상향 쓰기 O / 하향 쓰기 X
    - 특수 성형(*) 속성 : 동일 레벨에서만 읽기/쓰기 가능
    - 보안 단계가 높은 정보를 훔치는 트로이 목마 공격이 불가능하다.
    - 문제점
        - 지나치게 기밀성에 치중하여 무결성/가용성은 고려하지 않음
        - 은닉 채널을 다루지 않음 (-> 기밀성이 훼손될 가능성이 있음)
    
    # 비바 무결성 모델(Biba Integrity Model)
    - BLP를 보완한 무결성 모델(MAC)
    - 무결성의 목표 중 비인가자에 의한 부적절한 변조방지만을 목적으로 한다.
    - 보안 규칙
        - 상급 보안 계층 / 읽기 : O / 쓰기 : X / 읽기/쓰기 : X
        - 할당된 보안 계층 / 읽기 : O / 쓰기 : O / 읽기/쓰기 : O
        - 하급 보안 계층 / 읽기 : X / 쓰기 : O / 읽기/쓰기 : O
    - 단순 무결성 속성 : 상향 읽기 O / 하향 읽기 X
    - 성형(*) 무결성 속성 : 상향 쓰기 X / 하향 쓰기 O
    - 호출 속성 : 상향 호출 X / 하향 호출 O

    # 클락-윌슨 무결성 모델(Clark-Wilson Integrity Model)
    - 조금 더 정교하고 실제적인 무결성 모델
    - 무결성의 3가지 목표(비인가자/허가된 사용자에 의한 부적절한 변조방비, 내부/외부 일치성 유지)를 제공
    - 상업용으로 설계됨
    - 사용자는 프로그램을 통새서만 객체에 접근할 수 있다.

    # 만리장성 모델(Chinese Wall Model)
    - 정보 흐름 모델을 기반으로 주체와 객체 사이에서 이해 충돌을 야기하는 방식으로 정보가 흐르지 않도록 함
    - MAC, DAC 모델

    # -----------------------------------------------------------------------------------------------------

    # 접근통제 보안위협 및 대응책
    
    # 패스워드 크래커
    - 사전 공격(Dictionary Attack) : 패스워드 사전 파일을 이용하여 접속 계정을 알아내는 해킹 방법
    - 무차별 공격(Brute-force Attack) : 성공할 때까지 가능한 모든 조합의 경우의 수를 시도해 공격하는 방법
    - 레인보우 테이블을 이용한 공격 : 일정 수의 패스워드와 해시(hash)로 이루어진 체인(Chain)을 무수히 만들어 놓은 테이블
    
    # -----------------------------------------------------------------------------------------------------

    # ICT 기반 사회공학 공격 기법
    - 사회공학(Social Engineering) : 신뢰할 수 있는 개인이나 조직을 사칭하여 공격대상의 민감한 정보를 빼내는 공격 기법
    - 피싱(Phishing) : 공격 대상에게 E-mail을 발송하여 Phisher들이 운영하는 위조된 사이트로 이동시킨 후, 개인 정보를 요구하는 공격 기법
    - 파밍(Pharming) : 정상적인 사이트로의 접속 요청을 위조 사이트로 방향을 바꾸어 개인정보를 탈취하는 기법
    - 스미싱(SMishing) : SMS+Phishing, SMS 을 통해 사용자를 속여 악성 소프트웨어 설치를 유도하고, 해당 소프트웨어를 통해 개인정보를 탈취하거나 금전을 요구하는 기법
    
    # -----------------------------------------------------------------------------------------------------

PART4. 시스템 보안
- 4.0 운영체제 개요
    # 운영체제 개념
    - 컴퓨터 시스템의 각종 자원을 효율적으로 관리하고 운영하게 하여 사용자에게 편의성을 제공0
    - 목적
        - 처리량의 향상
        - 반환시간의 최소화
        - 응답 시간의 최소화
        - 사용가능도 향상
        - 신뢰도 향상
    
    # 운영체제의 이중연산 모드
    - OS의 적절한 동작을 보장하기 위해 OS 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다.
    - 사용자 모드 / 커널 모드(슈퍼바이저 모드, 특권 모드)
    - 사용자 모드에서는 제한적인 명령어만 사용 가능하고, 관리자 모드에서는 모든 명령어 사용 가능하다.
    - 사용자 Application은 시스템 호출(System Call)을 통해 OS로부터 서비스를 요청한다.

    # 운영체제 구조
    - 커널(Kernel) : OS의 핵심부분으로 주기억장치에 상주하며 프로세스와 파일을 관리
    - 모놀리식(monolithic) 구조
        - 시스템 관리에 필요한 모든 기능이 커널 레벨에서 동작하는 방식
        - 시스템 호출 인터페이스나 커널 안에서 통신하는 경우 오버헤드가 거의 없다.
        - 구현하기 어렵고, 유지보수가 힘듦. (커널 코드 전체를 재컴파일해야 한다.)
    - 마이크로 커널(Microkernels) 구조
        - 가장 기본이 되는 서비스만을 커널에 포함시켜 다른 기능들을 유저 레벨에서 각각의 프로세스로 구현하는 방식
        - 소스코드의 크기가 작고, 기능 수정 필요시 해당 기능이 들어있는 프로세스만 재컴파일하면 된다.
    - 계층적 접근(Layered Approach)
        - 계층 1 : 프로세서 관리
        - 계층 2 : 기억장치(메모리) 관리
        - 계층 3 : 프로세스 관리
        - 계층 4 : 주변장치 관리
        - 계층 5 : 파일과 데이터 관리

    # -----------------------------------------------------------------------------------------------------

    # 운영체제 주요 구성기술

    # 프로세스(Process)
    - 프로세스 : 실행 중인 프로그램. 프로세스 제어 블록(PCB, Process Control Block)을 가진 프로그램
    - 스레드(Thread) : 프로세스 하위 개념이며, 각각의 스레드는 독립적인 제어흐름을 가지고 자신만의 스택과 레지스터를 가진다.
    - PCB(Process Control Block)
        - 프로세스를 관리하는데 필요한 모든 정보를 유지하는 자료구조 테이블
        - 포함된 정보 : 프로세스 상태, 프로그램 카운터, CPU 레지스터, CPU 스케줄링 정보, 메모리 관리 정보, 회계 정보, I/O, 상태 정보
    - 상태전이도

    # CPU 스케줄링
    - FCFS(First Come First Service) : CPU를 먼저 요청한 프로세스가 CPU를 먼저 할당 받는 방식 (비선점)
    - SJF(Shortest Job First)
        - 작업수행시간(버스트시간)이 짧은 작업을 우선적으로 처리
        - 비선점 방식이며, 버스트시간이 긴 작업은 시간이 많이 걸림
    - HRN(Highest Response ratio Nest)
        - 대기시간이 긴 프로세스의 우선순위를 높여 기아상태를 해결
        - 비선점 방식
    - RR(Round Robin)
        - FCFS 방식에 시간 할당량 개념을 도입한 방식
        - 수행중인 프로세스가  할당된 시간을 초과하면 다음 프로세스가 선점하여 작업을 수행한다.
        - 시간할당량 증가 - FCFS 방식과 동일해질 수 있다.
        - 시간할당량 감소 - 많은 문맥교환으로 오버헤드 증가
    - SRT(Shortest Remaining Time)
        - SJF 방식과 동일하게 준비 큐에 있는 프로세스들 중 가장 짧은 버스트시간의 프로세스를 먼저 수행한다.
        - 선점 방식
    - 다단계 큐(MLQ, Multi-Level Queue)
        - 서로 다른 작업을 각각의 큐에서 처리 (선점)
        - 각각의 큐는 다른 스케줄링 알고리즘을 가질 수 있다.
    - 다단계 피드백 큐(MFQ, Multi-level Feedback Queue)
        - 프로세스가 들어오면 높은 우선순위를 할당해 단계 1에서 수행하고, 시간할당량을 초과하면 다음 낮은 우선순위의 큐에서 수행 (선점)
        - 가장 낮은 우선순위의 큐에서는 RR 방식으로 작업 처리
        - CPU와 I/O 장치의 효율을 높일 수 있다.
    
    # -----------------------------------------------------------------------------------------------------
    
    # 교착상태(Deadlock)
    - 둘 이상의 서로 다른 프로세스가 자신이 요구한 자원을 할당 받아 점유하고 있으면서 상호간에 상대방 프로세스에 할당되어 있는 자원을 요구하는 경우에 발생
    - 교착상태 발생하기 위한 4가지 조건
        - 상호배제 : 프로세스가 자원을 배타적으로 점유
        - 점유와 대기 : 프로세스는 하나의 자원을 점유하고 있으면서, 다른 자원을 할당 받기 위해 대기
        - 비선점
        - 환형 대기 : 프로세스와 자원의 할당/요청 관계가 원형을 이룸
    
    # 메모리 관리
    - 반입(Fetch) 정책 : 주기억장치에 적재할 다음 프로그램이나 자료를 언제 가져올 것인가를 결정하는 문제
        - 요구 반입(Demand fetch) 정책 : 어떤 프로그램이나 자료가 참조되는 시점에 주기억장치에 적재
        - 예상 반입(Anticipatory fetch) 정책 : 앞으로 요구될 가능성이 큰 프로그램이나 자료를 미리 주기억장치에 적재
    - 배치(Placement) 정책 : 새로 반입된 자료나 프로그램을 주기억장치의 어디에 위치시킬 것인가를 결정하는 문제
        - 최초 적합 : 첫 번째 사용 가능한 가용 공간을 할당
        - 최적 적합 : 사용 가능한 공간들 중에서 가장 작은 것을 할당
        - 최악 적합 : 가장 큰 가용 공간을 할당
    - 교체(Replacement) 정책 : 새로 들어온 프로그램이 들어갈 장소를 확보하기 위해 어떤 프로그램을 주기억장치에서 제거할 것인가를 결정하는 문제
        - FIFO(First In First Out) : 메모리에 가장 먼저 들어온 페이지부터 교체한다.
        - 최적(Optimal) 교체(OPT) : 가장 낮은 페이지 부재율을 가진 알고리즘
        - LRU(Least Recently Used)
            - 가장 널리 사용되는 방법으로, 가장 오랫동안 사용되지 않은 페이지를 교체하는 기법
            - 지역성에 의존하며, 불러왔던 시간을 기록하기 위한 오버헤드 발생하며 구현하기 어렵다.
        - LRU 근사 페이지 교체 :: SCR(Second Chance Replacement)
            - 참고 Bit를 두어 FIFO의 단점인 오랫동안 주기억장치에 있으면서 자주 쓰이던 페이지가 교체되는 것을 막기 위한 기법.
            - 참조 bit가 0이면 교체 / 1이면 0으로 변경 후 다시 큐에 적재
        - LRU 근사 페이지 교체 :: NUR(Not Used Recently)
            - LRU의 단점인 시간 오버헤드를 적게 하는 기법
            - 참조 Bit와 변경 Bit를 사용
        - LFU(Least Frequently Used)
            - 참조 횟수가 가장 적은 페이지를 교체하는 기법
            - 최근에 적재된 페이지가 교체될 가능성이 있다.
        - MFU(Most Frequently Used)
            - 참조 횟수가 가장 큰 페이지를 교체하는 기법
            - LFU와 MFU는 잘 사용되지 않음
    - 쓰레싱(Thrashing)
        - 너무 자주 페이지 교체가 일어나는 현상.
        - 페이지 교체 증가 -> 페이지 부재 빈번 -> 처리시간 < 교체시간
    - 페이지 부재 빈도(PFF, Page-Fault Frequency)