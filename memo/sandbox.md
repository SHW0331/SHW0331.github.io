# section2 Topic
x64dbg를 활용한 리버스 엔지니어링에 대한 숙련도
Exe 파일을 비워서 사용자 정의 명령어 삽입
코드 케이브를 사용해 추가된 명령어 주입
기존 exe 프로그램의 실행 흐름 수정
프로세스 메모리에 직접 접근
프로세스 메모리 해킹 및 수정
기존 함수 수정 또는 새로운 기능 추가


# 7FFF4B100731, 401580 두 주소의 차이
물리 주소 : [7FF4B100731]
- 물리 주소(absolute address)는 실행 중인 프로그램이 메모리에 실제로 로드된 위치를 나타냄
- 이 주소는 프로그램이 운영체제에 의해 메모리로 로드될 때 할당된 Base Address를 포함한 절대적인 메모리 위치

- 예시 :
- 프로그램의 베이스 주소 : 7FF4B100000
- 프로그램 내부 오프셋 : 731
- 물리 주소 = 베이스 주소 + 오프셋 = 7FFF4B100731

논리 주소 : [401580]
- 논리 주소(relative address)는 프로그램이 로드되지 않은 상태에서, 프로그램 내부에서 참조되는 오프셋을 기준으로 한 주소
- 실행 파일(PE 파일)의 Image Base Address에 상대적으로 계산된 주소

- 예시
- 프로그램의 Image Base가 400000으로 설정되었다고 가정
- 오프셋 : 1580
- 논리주소 = Base Address + 오프셋 = 401580


# 모든 함수는 PUSH 명령어로 시작한다.
- 디버깅에서 PUSH, MOV, POP 명령어가 함수의 시작과 끝에서 보이는 것은 함수 호출의 규칙(Calling Convention)과 스택 프레임(Stack Frame) 관리와 관련이 있다.

[why?]
1. Base Pointer (RBP)는 기준점
- 함수가 실행될 떄, RBP는 스택 프레임의 기준점이 된다.
- 이를 통해 함수가 사용하는 로컬 변수와 매개변수를 쉽게 참조할 수 있다.

2. Base Pointer를 스택에 저장하는 이유
- 이전 함수의 RBP 값을 스택에 저장(PUSH RBP)해서 함수가 끝난 후 복구할 수 있도록 한다.

3. Base Pointer를 새로 설정
- 새로운 함수에서 **MOV RBP, RSP**로 현재 스택 포인터를 RBP로 설정
- 이제 RBP를 기준으로 데이터(로컬 변수, 매개변수)에 안정적으로 접근 가능

4. 함수 실행이 끝나면 복구
- 함수가 끝날 때 **POP RBP**를 사용하여 이전 함수의 RBP 값을 복구
- 리턴 주소는 RET 명령어를 통해 복구되고, 호출한 함수로 복귀

[추가질문]
1. 그렇다면, 그냥 RSP 값을 참조해서 쓰면 안될까?
- RSP 값을 바로 참조해서 사용하지 않는 이유는 **스택 포인터(RSP)**가 함수 실행 중 계속 변동하기 때문이다.
- RSP는 스택의 **최상단(top)**을 가리키기 때문에 데이터를 PUSH/POP 할 때마다 값이 변함
- 반면 RBP는 함수 실행 중 고정된 값으로 유지되기 때문에, 데이터를 안정적으로 참조할 수 있음

[요약]
- RSP: 스택의 최상단을 가리키며, 데이터 PUSH/POP에 따라 계속 변동 → 참조하기 어려움.
- RBP: 함수 실행 중 고정된 기준점 역할을 하며, 데이터를 안정적으로 참조 가능.


# 바이너리 편집에서 NOP으로 채우기
- 바이너리 편집에서 NOP로 채우는 것은 코드의 특정 부분을 중립적인 명령어(아무 동작도 하지 않는 명령어)로 대체하는 작업
- 이는 코드의 동작을 변경하거나, 특정 명령어를 제거하면서 프로그램의 흐름에 최소한의 영향을 주기 위해 사용
- NOP (No Operation), 명령어의 크기만큼 CPU 사이클을 소비하지만, 프로그램 상태(레지스터, 메모리)에는 영향을 주지 않음


# 실행 환경 
- Compatibility Mode (x86) 32-bit mode
- 64-bit CPU에서 32-bit 코드를 실행하기 위한 모드
- 기존의 32-bit 애플리케이션을 지원하기 위해 제공

- 64 bit-mode
- CPU가 64-bit 명령어 세트와 레지스터를 활용하는 고성능 모드
- 64-bit 애플리케이션을 실행하며, 더 큰 메모리와 레지스터를 사용할 수 있음


# 숫자의 표기법
[0x112233]
- **0x**는 16진수(Hexadecimal) 숫자를 나타내는 접두사
- 112233은 16진수로 작성된 숫자
- 각 자리의 값은 16을 기반으로 계산

[112233]
- 접두사가 없는 숫자는 일반적으로 **10진수(Decimal)**로 해석
- 112233은 10진수로, 숫자 자체가 이미 10진수 표현


# Little Endian Convention?
**가장 낮은 바이트(Least Significant Byte, LSB)**를 가장 낮은 메모리 주소에 먼저 저장

[why?]
1. 효율성 : 낮은 바이트부터 읽으면 작은 숫자 연산이 더 빨라질 수 있다.
2. 호환성 : 다양한 시스템에서 데이터 크기가 다를 경우 하위 호환이 용이하다.

[예시] : 숫자 0x1234 를 메모리에 저장 (Little Endian)
- 16진수 2바이트로 나누기 : 
- 0x12(상위 바이트: MSB, Most Significant Byte) 
- 0x34(하위 바이트: LSB, Least Significant Byte) 

- 가장 작은 값(LSB, 0x34) -> 낮은 주소에 저장
- 0x00 | 0x34 ; LSB

- 가장 큰 값(MSB, 0x12) -> 높은 주소에 저장
- 0x01 | 0x12 ; MSB

- 따라서 결과 값은 HEX `34 12`

[핵심]
- 가장 낮은 바이트를 가장 낮은 메모리 주소에 저장
- 숫자 자체는 변하지 않음
- 저장 순서만 바뀜
